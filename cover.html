
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cloud-mta-build-tool/cmd/builders/commands.go (77.8%)</option>
				
				<option value="file1">cloud-mta-build-tool/cmd/builders/process.go (80.0%)</option>
				
				<option value="file2">cloud-mta-build-tool/cmd/exec/exec.go (0.0%)</option>
				
				<option value="file3">cloud-mta-build-tool/cmd/fsys/fsops.go (0.0%)</option>
				
				<option value="file4">cloud-mta-build-tool/cmd/fsys/path.go (0.0%)</option>
				
				<option value="file5">cloud-mta-build-tool/cmd/gen/makefile.go (0.0%)</option>
				
				<option value="file6">cloud-mta-build-tool/cmd/gen/script.go (0.0%)</option>
				
				<option value="file7">cloud-mta-build-tool/cmd/logs/logger.go (0.0%)</option>
				
				<option value="file8">cloud-mta-build-tool/cmd/mta/converter/mtad.go (100.0%)</option>
				
				<option value="file9">cloud-mta-build-tool/cmd/mta/metainfo/desc.go (62.5%)</option>
				
				<option value="file10">cloud-mta-build-tool/cmd/mta/mta.go (0.0%)</option>
				
				<option value="file11">cloud-mta-build-tool/cmd/mta/process.go (40.0%)</option>
				
				<option value="file12">cloud-mta-build-tool/validations/yaml_schema.go (98.9%)</option>
				
				<option value="file13">cloud-mta-build-tool/validations/yaml_validate.go (98.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package builders

import (
        "cloud-mta-build-tool/cmd/mta/models"
)

type CommandList struct {
        Info    string
        Command []string
}

// CommandProvider - Get build command's to execute
func CommandProvider(modules models.Modules) []CommandList <span class="cov0" title="0">{
        //Get config from ./commands_cfg.yaml as generated artifacts from source
        commands := Parse(CommandsConfig)
        return mesh(modules, commands)
}</span>

// Match the object according to type and provide the respective command
func mesh(modules models.Modules, commands Builders) []CommandList <span class="cov8" title="1">{
        //The object support deep struct for future use, can be simplified to flat object
        cmds := make([]CommandList, 1)
        for i, b := range commands.Builders </span><span class="cov8" title="1">{
                //Return only matching types
                if modules.Type == b.Name </span><span class="cov8" title="1">{
                        cmds[i].Info = b.Info
                        for _, cmd := range b.Type </span><span class="cov8" title="1">{
                                cmds[i].Command = append(cmds[i].Command, cmd.Command)
                        }</span>
                }
        }
        <span class="cov8" title="1">return cmds</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package builders

import (
        "gopkg.in/yaml.v2"

        "cloud-mta-build-tool/cmd/logs"
)

//Parse the builders command list
func Parse(data []byte) Builders <span class="cov8" title="1">{
        commands := Builders{}
        err := yaml.Unmarshal(data, &amp;commands)
        if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Error("Yaml file is not valid, Error: " + err.Error())
        }</span>
        <span class="cov8" title="1">return commands</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package exec

import (
        "bufio"
        "fmt"
        "os/exec"
        "path/filepath"
        "time"

        "cloud-mta-build-tool/cmd/logs"
)

func Execute(cmdParams [][]string) error <span class="cov0" title="0">{

        for _, cp := range cmdParams </span><span class="cov0" title="0">{

                logs.Logger.Infof("Executing %s for module %s...", cp[1:], filepath.Base(cp[0]))
                cmd := exec.Command(cp[1], cp[2:]...)

                cmd.Dir = cp[0]
                // During the running process get the standard output
                stdout, err := cmd.StdoutPipe()
                if err != nil </span><span class="cov0" title="0">{
                        logs.Logger.Errorf("%s cmd.StdoutPipe() error: %s ", cp[1:], err, "\n")
                        return err
                }</span>
                // During the running process get the standard output
                <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
                if err != nil </span><span class="cov0" title="0">{
                        logs.Logger.Errorf("cmd.StderrPipe() error: ", cp[1:], err, "\n")
                        return err
                }</span>

                // Start indicator:
                <span class="cov0" title="0">shutdownCh := make(chan struct{})
                go indicator(shutdownCh)

                // Execute the process immediately
                if err = cmd.Start(); err != nil </span><span class="cov0" title="0">{
                        logs.Logger.Errorf("%s start error: %v\n", cp[1:], err)
                        return err
                }</span>
                // Stream command output:
                // Creates a bufio.Scanner that will read from the pipe
                // that supplies the output written by the process.
                <span class="cov0" title="0">scanout := bufio.NewScanner(stdout)
                scanerr := bufio.NewScanner(stderr)
                // instructs the scanner to read the input by runes instead of the default by-lines.
                scanout.Split(bufio.ScanRunes)
                for scanout.Scan() </span><span class="cov0" title="0">{
                        fmt.Print(scanout.Text())
                }</span>
                // instructs the scanner to read the input by runes instead of the default by-lines.
                <span class="cov0" title="0">scanerr.Split(bufio.ScanRunes)
                for scanerr.Scan() </span><span class="cov0" title="0">{
                        fmt.Print(scanerr.Text())
                }</span>

                <span class="cov0" title="0">if scanout.Err() != nil </span><span class="cov0" title="0">{
                        logs.Logger.Errorf("Reading %s stdout error: %v\n", cp[1:], err)
                        return err
                }</span>

                <span class="cov0" title="0">if scanerr.Err() != nil </span><span class="cov0" title="0">{
                        logs.Logger.Errorf("Reading %s stderr error: %v\n", cp[1:], err)
                        return err
                }</span>
                // Get execution success or failure:
                <span class="cov0" title="0">if err = cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                        logs.Logger.Errorf("Error running %s: %v\n", cp[1:], err)
                        return err
                }</span>
                <span class="cov0" title="0">close(shutdownCh) // Signal indicator() to terminate
                logs.Logger.Infof("Finished %s", cp[1:])</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func indicator(shutdownCh &lt;-chan struct{}) <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        fmt.Print(".")</span>
                case &lt;-shutdownCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package dir

import (
        "archive/zip"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "cloud-mta-build-tool/cmd/constants"
        "cloud-mta-build-tool/cmd/logs"
)

// CreateDirIfNotExist - Create new dir
func CreateDirIfNotExist(dir string) string <span class="cov0" title="0">{
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err := os.MkdirAll(dir, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        logs.Logger.Error(err)
                }</span>
        }
        <span class="cov0" title="0">return dir</span>
}

// Archive module and mtar artifacts,
// compatible with the JAR specification
// to support the spec requirements
// Source path to zip -&gt; params[0])
// Target artifact  -&gt; ,params[1])
// Target path to zip -&gt; params[2])
func Archive(params ...string) error <span class="cov0" title="0">{

        zipfile, err := os.Create(params[1])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer zipfile.Close()

        archive := zip.NewWriter(zipfile)
        defer archive.Close()

        info, err := os.Stat(params[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Skip headers to support jar archive structure
        <span class="cov0" title="0">var baseDir string
        if info.IsDir(); len(params) &gt; 2 </span><span class="cov0" title="0">{
                baseDir = params[2]
        }</span> else<span class="cov0" title="0"> {
                baseDir = filepath.Base(params[0])
        }</span>

        <span class="cov0" title="0">if baseDir != "" </span><span class="cov0" title="0">{
                baseDir += "/"
        }</span>

        <span class="cov0" title="0">filepath.Walk(params[0], func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">header, err := zip.FileInfoHeader(info)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if baseDir != "" </span><span class="cov0" title="0">{
                        header.Name = filepath.Join(strings.TrimPrefix(path, baseDir))
                }</span>

                <span class="cov0" title="0">header.Method = zip.Deflate

                writer, err := archive.CreateHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer file.Close()
                _, err = io.Copy(writer, file)
                return err</span>
        })

        <span class="cov0" title="0">return err</span>
}

// CreateFile - create new file
func CreateFile(path string) *os.File <span class="cov0" title="0">{
        file, err := os.Create(path) // Truncates if file already exists
        if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Fatalf("Failed to create file: %s , %s", path, err)
        }</span>
        // /defer file.Close()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Fatalf("Failed to write to file: %s , %s", path, err)
        }</span>
        <span class="cov0" title="0">return file</span>
}

// CopyDir - copy directory content
func CopyDir(src string, dst string) (err error) <span class="cov0" title="0">{
        src = filepath.Clean(src)
        dst = filepath.Clean(dst)

        si, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !si.IsDir() </span><span class="cov0" title="0">{
                logs.Logger.Println("The provided source is not a directory")
        }</span>

        <span class="cov0" title="0">_, err = os.Stat(dst)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = os.MkdirAll(dst, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">entries, err := ioutil.ReadDir(src)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                srcPath := filepath.Join(src, entry.Name())
                dstPath := filepath.Join(dst, entry.Name())

                if entry.IsDir() </span><span class="cov0" title="0">{
                        // execute recursively
                        err = CopyDir(srcPath, dstPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        if entry.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">err = copyFile(srcPath, dstPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

// CopyFile - copy file content
func copyFile(src, dst string) (err error) <span class="cov0" title="0">{
        in, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer in.Close()

        out, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if e := out.Close(); e != nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }()

        <span class="cov0" title="0">_, err = io.Copy(out, in)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = out.Sync()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">si, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = os.Chmod(dst, si.Mode())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

// DefaultTempDirFunc - Currently the generated temp dir is one lvl up from the running project
// e.g. proj -&gt; go/src/mta tmpdir-&gt; go/src
// The tmp dir should be deleted after the process finished or failed
// TODO delete tmp in case of failure
func DefaultTempDirFunc(path string) string <span class="cov0" title="0">{
        tmpDir, _ := ioutil.TempDir(path, constants.TempFolder)
        return tmpDir
}</span>

// Load - load the mta.yaml file
func Load(path string) []byte <span class="cov0" title="0">{
        yamlFile, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Errorf("File not found for path %s, error is: #%v ", path, err)
                // YAML descriptor file not found abort the process
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logs.Logger.Debugf("The file loaded successfully:" + string(yamlFile))
        return yamlFile</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dir

import (
        "cloud-mta-build-tool/cmd/logs"
        "os"
        "path/filepath"
)

func GetPath() (dir string) <span class="cov0" title="0">{
        // TODO should get also from user
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Panicln(err)
        }</span>
        <span class="cov0" title="0">return wd</span>
}

func ProjectPath() string <span class="cov0" title="0">{

        projPath, err := filepath.Abs(filepath.Dir(os.Args[0]))
        if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Panicln(err)
        }</span>
        <span class="cov0" title="0">return projPath</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package gen

import (
        "gopkg.in/yaml.v2"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "text/template"

        "cloud-mta-build-tool/cmd/builders"
        "cloud-mta-build-tool/cmd/constants"
        fs "cloud-mta-build-tool/cmd/fsys"
        "cloud-mta-build-tool/cmd/logs"
        "cloud-mta-build-tool/cmd/mta/models"
        "cloud-mta-build-tool/cmd/proc"
)

//Make - Generate the makefile
func Make() <span class="cov0" title="0">{
        const MakeTmpl = "make.txt"
        var genFileName = "Makefile"
        var makeFile *os.File
        // Using the module context for the template creation
        mta := models.MTA{}
        type API map[string]string
        var data struct {
                File models.MTA
                API  API
        }
        // Get working directory
        projPath := fs.GetPath()

        // Create the init script file
        if _, err := os.Stat(projPath + constants.PathSep + genFileName); err == nil </span><span class="cov0" title="0">{
                // path/to/whatever exists
                makeFile = fs.CreateFile(projPath + constants.PathSep + genFileName + ".mta")
        }</span> else<span class="cov0" title="0"> {
                makeFile = fs.CreateFile(projPath + constants.PathSep + genFileName)
        }</span>

        // Read the MTA
        <span class="cov0" title="0">yamlFile, err := ioutil.ReadFile(projPath + "/mta.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Not able to read the mta.yaml file: #%v ", err)
        }</span>
        // Parse mta
        <span class="cov0" title="0">err = yaml.Unmarshal([]byte(yamlFile), &amp;mta)
        if err != nil </span><span class="cov0" title="0">{
                logs.Logger.Errorf("Not able to unmarshal the mta file ")
        }</span>

        <span class="cov0" title="0">data.File = mta
        // Create maps of the template method's
        funcMap := template.FuncMap{
                "CommandProvider": builders.CommandProvider,
                "OsCore":          proc.OsCore,
        }
        // Get the path of the template source code
        _, file, _, _ := runtime.Caller(0)

        container := filepath.Join(filepath.Dir(file), MakeTmpl)
        // parse the template txt file
        t, err := template.New(MakeTmpl).Funcs(funcMap).ParseFiles(container)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // Execute the template
        <span class="cov0" title="0">if err = t.Execute(makeFile, data); err != nil </span><span class="cov0" title="0">{
                logs.Logger.Error(err)
        }</span>
        //logs.Logger.Info("MTA build script was generated successfully: " + projPath + constants.PathSep + makefile)

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package gen

import (
        "io/ioutil"
        "log"

        "gopkg.in/yaml.v2"
        "path/filepath"
        "runtime"
        "text/template"

        "cloud-mta-build-tool/cmd/builders"
        "cloud-mta-build-tool/cmd/constants"
        fs "cloud-mta-build-tool/cmd/fsys"
        "cloud-mta-build-tool/cmd/logs"
        "cloud-mta-build-tool/cmd/mta/models"
)

// Generate - Generate mta build file
func Generate(path string) <span class="cov0" title="0">{

        const mtaScript = "makefile"
        // Using the module context for the template creation
        mta := models.MTA{}
        type API map[string]string
        var data struct {
                File models.MTA
                API  API
        }
        // Get working directory
        projPath := fs.GetPath()
        // Create the init script file

        bashFile := fs.CreateFile(projPath + constants.PathSep + mtaScript)
        // Read the MTA
        yamlFile, err := ioutil.ReadFile("mta.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("yamlFile.Get err   #%v ", err)
        }</span>
        // Parse mta
        <span class="cov0" title="0">err = yaml.Unmarshal([]byte(yamlFile), &amp;mta)
        data.File = mta

        // Create maps of the template method's
        funcMap := template.FuncMap{
                "CommandProvider": builders.CommandProvider,
        }
        // Get the path of the template source code
        _, file, _, _ := runtime.Caller(0)
        container := filepath.Join(filepath.Dir(file), "script.gotmpl")
        // parse the template txt file
        t, err := template.New("script.txt").Funcs(funcMap).ParseFiles(container)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // Execute the template
        <span class="cov0" title="0">if err := t.Execute(bashFile, data); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">logs.Logger.Info("MTA build script was generated successfully: " + projPath + constants.PathSep + mtaScript)</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package logs

import (
        "github.com/sirupsen/logrus"
        "github.com/x-cray/logrus-prefixed-formatter"
        "os"
)

const (
        MbtLogLevel = "MBT_LOG_LEVEL"
        DefLvl      = "info"
)

// Logger - logrus variable
var Logger *logrus.Logger

// NewLogger - init logger
func NewLogger() *logrus.Logger <span class="cov0" title="0">{

        var level logrus.Level
        lvl := getLogLevel()
        // In case level doesn't set will not print any message
        level = logLevel(lvl, level)
        logger := &amp;logrus.Logger{
                Out:   os.Stdout,
                Level: level,
                Formatter: &amp;prefixed.TextFormatter{
                        DisableColors:   false,
                        TimestampFormat: "2006-01-02 15:04:05",
                        FullTimestamp:   true,
                        ForceFormatting: true,
                },
        }
        Logger = logger
        return Logger
}</span>

// GetLogLevel - Get level from env
func getLogLevel() string <span class="cov0" title="0">{
        // TODO Check env if coming from external config or local
        lvl, _ := os.LookupEnv(MbtLogLevel)
        if lvl != "" </span><span class="cov0" title="0">{
                return lvl
        }</span>
        <span class="cov0" title="0">return DefLvl</span>
}

func logLevel(lvl string, level logrus.Level) logrus.Level <span class="cov0" title="0">{

        switch lvl </span>{
        case "debug":<span class="cov0" title="0">
                // Used for tracing
                level = logrus.DebugLevel</span>
        case "info":<span class="cov0" title="0">
                level = logrus.InfoLevel</span>
        case "error":<span class="cov0" title="0">
                level = logrus.ErrorLevel</span>
        case "warn":<span class="cov0" title="0">
                level = logrus.WarnLevel</span>
        case "fatal":<span class="cov0" title="0">
                level = logrus.FatalLevel</span>
        case "panic":<span class="cov0" title="0">
                level = logrus.PanicLevel</span>
        default:<span class="cov0" title="0">
                panic("The specified log level is not supported.")</span>
        }
        <span class="cov0" title="0">return level</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package converter

import (
        "strings"

        "cloud-mta-build-tool/cmd/mta/models"
        "cloud-mta-build-tool/cmd/platform"
)

// ConvertTypes file according to the deployed env
func ConvertTypes(mta models.MTA, platforms platform.Platforms, platform string) <span class="cov8" title="1">{
        //todo get from config
        const (
                SCHEMA_VERSION = "3.1"
        )
        for _, module := range platforms.Platforms </span><span class="cov8" title="1">{

                if module.Name == platform </span><span class="cov8" title="1">{
                        // Modify schema version
                        *mta.SchemaVersion = SCHEMA_VERSION
                        // Modify Types
                        for i, value := range module.Models </span><span class="cov8" title="1">{
                                //Check for types
                                if len(mta.Modules) &gt; i </span><span class="cov8" title="1">{
                                        if strings.Compare(value.NativeType, mta.Modules[i].Type) == 0 </span><span class="cov8" title="1">{
                                                //Modify the module type according the platform config
                                                mta.Modules[i].Type = value.PlatformType
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package metainfo

import (
        "cloud-mta-build-tool/cmd/constants"
        "cloud-mta-build-tool/cmd/fsys"
        "cloud-mta-build-tool/cmd/mta"
        "cloud-mta-build-tool/cmd/mta/converter"
        "cloud-mta-build-tool/cmd/mta/models"
        "cloud-mta-build-tool/cmd/platform"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
)

// The deployment descriptor shall be located within the META-INF folder of the JAR.
// The file MANIFEST.MF shall contain at least a name section for each MTA module contained in the archive.
// Following the JAR specification, the value of a name must be a relative path to a file or directory,
// or an absolute URL referencing data outside the archive.
// It is required to add a row MTA-module: &lt;modulename&gt; to each name section which corresponds to an MTA module,
// to bind archive file locations to module names as used in the deployment descriptor.
// The name sections with the MTA module attribute indicates the path to the file or directory which represents a module within the archive
// This used by deploy service to track the build project

const (
        MetaInf         = "/META-INF"
        Manifest        = "MANIFEST.MF"
        Mtad            = "mtad.yaml"
        NewLine         = "\n"
        ContentType     = "Content-Type: "
        MtaModule       = "MTA-Module: "
        ModuleName      = "Name: "
        ApplicationZip  = "application/zip"
        ManifestVersion = "Manifest-Version: 1.0"
)

//Set the MANIFEST.MF file
func setManifetDesc(file io.Writer, mtaStr []*models.Modules, modules []string) <span class="cov8" title="1">{
        // TODO create dynamically
        fmt.Fprint(file, ManifestVersion+NewLine)
        // TODO set the version from external config for automatic version bump during release
        fmt.Fprint(file, "Created-By: SAP Application Archive Builder 0.0.1")
        for _, mod := range mtaStr </span><span class="cov8" title="1">{
                //Print only the required module to support the partial build
                if len(modules) &gt; 0 &amp;&amp; mod.Name == modules[0] </span><span class="cov8" title="1">{
                        printToFile(file, mod)
                        break</span>
                } else<span class="cov8" title="1"> if len(modules) == 0 </span><span class="cov8" title="1">{
                        //Print all the modules
                        printToFile(file, mod)
                }</span>
        }
}

func printToFile(file io.Writer, mtaStr *models.Modules) <span class="cov8" title="1">{
        fmt.Fprint(file, NewLine)
        fmt.Fprint(file, NewLine)
        fmt.Fprint(file, ModuleName+mtaStr.Name+constants.DataZip)
        fmt.Fprint(file, NewLine)
        fmt.Fprint(file, MtaModule+mtaStr.Name)
        fmt.Fprint(file, NewLine)
        fmt.Fprint(file, ContentType+ApplicationZip)
}</span>

func GenMetaInf(tmpDir string, mtaStr models.MTA, modules []string) <span class="cov0" title="0">{
        // Create META-INF folder under the mtar folder
        dir.CreateDirIfNotExist(tmpDir + MetaInf)
        //Load platform configuration file

        platformCfg := platform.Parse(platform.PlatformConfig)
        // Modify MTAD object according to platform types
        //Todo platform should provided as command parameter
        converter.ConvertTypes(mtaStr, platformCfg, "cf")
        // Create readable Yaml before writing to file
        mtad := mta.Marshal(mtaStr)
        // Write back the MTAD to the META-INF folder
        err := ioutil.WriteFile(tmpDir+MetaInf+constants.PathSep+Mtad, mtad, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        // Create MANIFEST.MF file
        <span class="cov0" title="0">file := dir.CreateFile(tmpDir + MetaInf + constants.PathSep + Manifest)
        // Set the MANIFEST.MF file
        setManifetDesc(file, mtaStr.Modules, modules)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mta

import "cloud-mta-build-tool/cmd/mta/models"

const (
        PARENT = "../"
)

// SetMtaProp - set mta properties
func SetMtaProp(mtaStruct models.MTA) string <span class="cov0" title="0">{
        mtaDirName := mtaStruct.Id
        parentMtaDir := PARENT + mtaDirName
        return parentMtaDir
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package mta

import (
        "log"
        "os"

        "cloud-mta-build-tool/cmd/mta/models"
        "gopkg.in/yaml.v2"
)

// Parse MTA file
func Parse(yamlContent []byte) (out models.MTA) <span class="cov8" title="1">{
        mta := models.MTA{}
        // Format the YAML to struct's
        err := yaml.Unmarshal([]byte(yamlContent), &amp;mta)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Yaml file is not valid, Error: " + err.Error())

                os.Exit(-1)
        }</span>
        <span class="cov8" title="1">return mta</span>
}

// Marshal - edit the file
func Marshal(in models.MTA) []byte <span class="cov0" title="0">{
        mtads, err := yaml.Marshal(&amp;in)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(err.Error())
        }</span>

        <span class="cov0" title="0">return mtads</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// TODO: HO
// 1. Position information for schema issues (blocked)
// 2. Path information for schema issues.
// 3. Validate that regExp patterns are valid
// 4. regExp patterns also implicitly require a NotMapSequence validation
// 5. TypeValidations (Bool / Enum)

package mta_validate

import (
        "fmt"
        "github.com/smallfish/simpleyaml"
        "strings"
)

// Entry point that accepts a Yaml Schema as text and produces YAML validation functions
// and the schema issues detected.
func BuildValidationsFromSchemaText(yaml []byte) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        y, parseError := simpleyaml.NewYaml(yaml)
        if parseError != nil </span><span class="cov8" title="1">{
                schemaIssues = append(schemaIssues, parseError.Error())
                return validations, schemaIssues
        }</span>

        <span class="cov8" title="1">return buildValidationsFromSchema(y)</span>
}

// Internal YAML validation builder
// Will be called recursively and traverse the schema structure.
func buildValidationsFromSchema(schema *simpleyaml.Yaml) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        typeNode := schema.Get("type")
        typeNodeValue, _ := typeNode.String()
        if typeNode.IsFound() &amp;&amp; (typeNodeValue == "map" || typeNodeValue == "seq") </span><span class="cov8" title="1">{
                switch typeNodeValue </span>{
                // type: map
                // mapping:
                //   firstName:  {required: true}
                //   ...
                case "map":<span class="cov8" title="1">
                        mappingNode := schema.Get("mapping")
                        if !mappingNode.IsMap() </span><span class="cov8" title="1">{
                                schemaIssues = append(schemaIssues, "YAML Schema Error: &lt;mapping&gt; node must be a map")
                                return validations, schemaIssues
                        }</span>
                        <span class="cov8" title="1">newValidations, newSchemaIssues := buildValidationsFromMap(mappingNode)
                        schemaIssues = append(schemaIssues, newSchemaIssues...)
                        validations = append(validations, newValidations...)</span>
                // type: seq
                // sequence:
                //  - type: map
                //  mapping:
                //    name: {required: true}
                //    ...
                case "seq":<span class="cov8" title="1">
                        sequenceNode := schema.Get("sequence")
                        if !sequenceNode.IsArray() </span><span class="cov8" title="1">{
                                schemaIssues = append(schemaIssues, "YAML Schema Error: &lt;sequence&gt; node must be an array")
                                return validations, schemaIssues
                        }</span>

                        <span class="cov8" title="1">seqSize, _ := sequenceNode.GetArraySize()
                        if seqSize &gt; 1 </span><span class="cov8" title="1">{
                                schemaIssues = append(schemaIssues, "YAML Schema Error: &lt;sequence&gt; node can only have one item")
                                return validations, schemaIssues
                        }</span>

                        // A sequence schema node has exactly only 1 element
                        <span class="cov8" title="1">sequenceItemNode := sequenceNode.GetIndex(0)
                        sequenceValidations, newSchemaIssues := buildValidationsFromSequence(sequenceItemNode)
                        schemaIssues = append(schemaIssues, newSchemaIssues...)
                        validations = append(validations, sequenceValidations...)</span>
                }
                // {required: true, pattern: /^[a-z]+$/}
        } else<span class="cov8" title="1"> {
                return buildLeafValidations(schema)
        }</span>

        <span class="cov8" title="1">return validations, schemaIssues</span>
}

// Create Validations for a mapping
// each key's inner validations will be wrapping in a "Property" validation
func buildValidationsFromMap(y *simpleyaml.Yaml) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        validations = append(validations, TypeIsMap())

        keys, _ := y.GetMapKeys()
        for _, key := range keys </span><span class="cov8" title="1">{
                value := y.Get(key)
                propInnerValidations, newSchemaIssues := buildValidationsFromSchema(value)
                schemaIssues = append(schemaIssues, newSchemaIssues...)
                propWrapperValidation := Property(key, propInnerValidations...)
                validations = append(validations, propWrapperValidation)
        }</span>
        <span class="cov8" title="1">return validations, schemaIssues</span>
}

// Creates validations for a Sequence
// Will wrap the nested checks with a "TypeIsArray" check and iterate over the elements
// using "ForEach"
func buildValidationsFromSequence(y *simpleyaml.Yaml) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        sequenceInnerValidations, newIssues := buildValidationsFromSchema(y)
        seqChecksWrapper := SequenceFailFast(TypeIsArray(), ForEach(sequenceInnerValidations...))
        validations = append(validations, seqChecksWrapper)
        schemaIssues = append(schemaIssues, newIssues...)

        return validations, newIssues
}</span>

// Will create the "edge" nodes validations, these are specific checks
// for a specific path at the end of the YAML Schema
// e.g: {required: true, pattern: /^[a-zA-Z]$/}
func buildLeafValidations(y *simpleyaml.Yaml) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        validations, schemaIssues = invokeLeafValidation(y, validations, schemaIssues, buildTypeValidation)

        validations, schemaIssues = invokeLeafValidation(y, validations, schemaIssues, buildPatternValidation)

        // Special handling is needed for "Optional" and "Required" Validations, must be invoked last
        // and receive all previous built validations as extra wrapping will be done here.
        return buildOptionalOrRequiredValidation(y, validations, schemaIssues)

}</span>

func buildOptionalOrRequiredValidation(y *simpleyaml.Yaml, validations []YamlCheck, schemaIssues []string) ([]YamlCheck, []string) <span class="cov8" title="1">{
        requiredNode := y.Get("required")
        if requiredNode.IsFound() </span><span class="cov8" title="1">{
                requiredValue := getLiteralStringValue(requiredNode)
                if requiredValue != "true" &amp;&amp; requiredValue != "false" </span><span class="cov8" title="1">{
                        schemaIssues = append(schemaIssues,
                                fmt.Sprintf("YAML Schema Error: &lt;required&gt; node must be a boolean but found &lt;%s&gt;", requiredValue))
                        return validations, schemaIssues
                }</span>

                // When a "required" check is needed there is no need to perform additional validations
                // if the property is missing, thus we use "SequenceFailFast"
                <span class="cov8" title="1">if requiredValue == "true" </span><span class="cov8" title="1">{
                        // The required check must be performed first in the sequence.
                        validationsWithRequiredFirst := append([]YamlCheck{Required()}, validations...)
                        validations = []YamlCheck{SequenceFailFast(validationsWithRequiredFirst...)}
                        // When "required" is false, we must only perform additional validations
                        // if the property actually exists, thus we use "Optional"
                }</span> else<span class="cov8" title="1"> {
                        // An Optional wraps all our other validations.
                        validations = []YamlCheck{Optional(validations...)}
                }</span>
        }
        <span class="cov8" title="1">return validations, schemaIssues</span>
}

func buildTypeValidation(y *simpleyaml.Yaml) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        typeNode := y.Get("type")
        if typeNode.IsFound() </span><span class="cov8" title="1">{
                typeValue, stringErr := typeNode.String()
                if stringErr != nil </span><span class="cov8" title="1">{
                        schemaIssues = append(schemaIssues, "YAML Schema Error: &lt;type&gt; node must be a string")
                        return validations, schemaIssues
                }</span>
                <span class="cov8" title="1">if typeValue == "bool" </span><span class="cov8" title="1">{
                        validations = append(validations, TypeIsBoolean())
                }</span> else<span class="cov0" title="0"> if typeValue == "enum" </span>{<span class="cov0" title="0">
                        // TODO: TBD
                }</span>
        }
        <span class="cov8" title="1">return validations, schemaIssues</span>
}

func buildPatternValidation(y *simpleyaml.Yaml) ([]YamlCheck, []string) <span class="cov8" title="1">{
        var validations []YamlCheck
        var schemaIssues []string

        patternNode := y.Get("pattern")
        if patternNode.IsFound() </span><span class="cov8" title="1">{
                patternValue, err := patternNode.String()
                if err != nil </span><span class="cov8" title="1">{
                        schemaIssues = append(schemaIssues, "YAML Schema Error: &lt;pattern&gt; node must be a string")
                        return validations, schemaIssues
                }</span>
                // TODO: we must validate: NOT MAP/SEQ
                // TODO: validate that the pattern is valid
                <span class="cov8" title="1">patternWithoutSlashes := strings.TrimSuffix(strings.TrimPrefix(patternValue, "/"), "/")
                validations = append(validations, MatchesRegExp(patternWithoutSlashes))</span>
        }
        <span class="cov8" title="1">return validations, schemaIssues</span>
}

// Utility to reduce verbosity
func invokeLeafValidation(y *simpleyaml.Yaml, validations []YamlCheck, schemaIsssues []string, leafBuilder func(y *simpleyaml.Yaml) ([]YamlCheck, []string)) ([]YamlCheck, []string) <span class="cov8" title="1">{
        newValidations, newSchemaIssues := leafBuilder(y)
        validations = append(validations, newValidations...)
        schemaIsssues = append(schemaIsssues, newSchemaIssues...)

        return validations, schemaIsssues
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// TODO: Implement additional validations
// 1. Unique:
// 3. TypeIsEnum
// 4. Allowed Properties.
// 5. TypeIsNotMapOrSet

package mta_validate

import (
        "fmt"
        "github.com/smallfish/simpleyaml"
        "regexp"
        "strings"
)

type YamlValidationIssue struct {
        msg string
}

type YamlCheck func(y *simpleyaml.Yaml, path []string) []YamlValidationIssue

// DSL method to execute validations on a sub node(property) of a YAML tree.
// Can be nested to check properties farther and farther down the tree.
func Property(propName string, checks ...YamlCheck) YamlCheck <span class="cov8" title="1">{
        return func(y *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                var issues []YamlValidationIssue
                yProp := y.Get(propName)

                // Will perform all the validations without stopping
                for _, check := range checks </span><span class="cov8" title="1">{
                        newIssues := check(yProp, append(path, propName))
                        issues = append(issues, newIssues...)
                }</span>

                <span class="cov8" title="1">return issues</span>
        }
}

// DSL method to execute validations in order and break early as soon as the first one fails
// This is very useful if a certain validation cannot be executed without the previous ones succeeding.
// For example: matching vs a regExp should not be performed for a property that is not a string.
func Sequence(
        checks ...YamlCheck) YamlCheck <span class="cov8" title="1">{

        return sequenceInternal(false, checks...)
}</span>

// DSL method to execute validations in order and break early as soon as the first one fails
// This is very useful if a certain validation cannot be executed without the previous ones succeeding.
// For example: matching vs a regExp should not be performed for a property that is not a string.
func SequenceFailFast(
        checks ...YamlCheck) YamlCheck <span class="cov8" title="1">{

        return sequenceInternal(true, checks...)
}</span>

func sequenceInternal(failfast bool,
        checks ...YamlCheck) YamlCheck <span class="cov8" title="1">{

        return func(y *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                var issues []YamlValidationIssue

                for _, check := range checks </span><span class="cov8" title="1">{
                        newIssues := check(y, path)
                        // Only perform the next validation, if the previous one succeeded
                        if len(newIssues) &gt; 0 </span><span class="cov8" title="1">{
                                issues = append(issues, newIssues...)
                                if failfast </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">return issues</span>
        }
}

// DSL method to iterate over a YAML array items
func ForEach(checks ...YamlCheck) YamlCheck <span class="cov8" title="1">{

        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                arrSize, _ := yProp.GetArraySize()

                var issues []YamlValidationIssue

                validation := Sequence(checks...)

                for i := 0; i &lt; arrSize; i++ </span><span class="cov8" title="1">{
                        yElem := yProp.GetIndex(i)
                        elemErrors := validation(yElem, append(path, fmt.Sprintf("[%d]", i)))
                        issues = append(issues, elemErrors...)
                }</span>

                <span class="cov8" title="1">return issues</span>
        }
}

// DSL method to ensure a property exists.
// Note that this has no context, the property being checked is provided externally
// via the "Property" DSL method.
func Required() YamlCheck <span class="cov8" title="1">{
        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                if !yProp.IsFound() </span><span class="cov8" title="1">{
                        return []YamlValidationIssue{{msg: fmt.Sprintf("Missing Required Property &lt;%s&gt; in &lt;%s&gt;",
                                last(path),
                                buildPathString(dropRight(path)))}}
                }</span>

                <span class="cov8" title="1">return []YamlValidationIssue{}</span>
        }
}

// DSL method that will only perform validations if the property exists
// Useful to avoid executing validations on none mandatory properties which are not present.
func Optional(checks ...YamlCheck) YamlCheck <span class="cov8" title="1">{
        return func(y *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                var issues []YamlValidationIssue

                // If an Optional property is not found
                // no sense in executing the validations.
                if !y.IsFound() </span><span class="cov8" title="1">{
                        return issues
                }</span>

                <span class="cov8" title="1">for _, check := range checks </span><span class="cov8" title="1">{
                        newIssues := check(y, path)
                        issues = append(issues, newIssues...)
                }</span>

                <span class="cov8" title="1">return issues</span>
        }
}

// TODO: This should actually be TypeIsNotMapSequence (literal)
func TypeIsString() YamlCheck <span class="cov8" title="1">{
        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                _, err := yProp.String()

                if err != nil </span><span class="cov8" title="1">{
                        return []YamlValidationIssue{{msg: fmt.Sprintf("Property &lt;%s&gt; must be of type &lt;string&gt;", buildPathString(path))}}
                }</span>

                <span class="cov8" title="1">return []YamlValidationIssue{}</span>
        }
}

func TypeIsArray() YamlCheck <span class="cov8" title="1">{
        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                _, err := yProp.Array()

                if err != nil </span><span class="cov8" title="1">{
                        return []YamlValidationIssue{{msg: fmt.Sprintf("Property &lt;%s&gt; must be of type &lt;Array&gt;", buildPathString(path))}}
                }</span>

                <span class="cov8" title="1">return []YamlValidationIssue{}</span>
        }
}

func TypeIsMap() YamlCheck <span class="cov8" title="1">{
        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                _, err := yProp.Map()

                if err != nil </span><span class="cov8" title="1">{
                        return []YamlValidationIssue{{msg: fmt.Sprintf("Property &lt;%s&gt; must be of type &lt;Map&gt;", buildPathString(path))}}
                }</span>

                <span class="cov8" title="1">return []YamlValidationIssue{}</span>
        }
}

func TypeIsBoolean() YamlCheck <span class="cov8" title="1">{
        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                _, err := yProp.Bool()

                if err != nil </span><span class="cov8" title="1">{
                        return []YamlValidationIssue{{msg: fmt.Sprintf("Property &lt;%s&gt; must be of type &lt;Boolean&gt;", buildPathString(path))}}
                }</span>

                <span class="cov8" title="1">return []YamlValidationIssue{}</span>
        }
}

func MatchesRegExp(pattern string) YamlCheck <span class="cov8" title="1">{
        regExp, _ := regexp.Compile(pattern)

        return func(yProp *simpleyaml.Yaml, path []string) []YamlValidationIssue </span><span class="cov8" title="1">{
                strValue := getLiteralStringValue(yProp)

                if !regExp.MatchString(strValue) </span><span class="cov8" title="1">{
                        return []YamlValidationIssue{
                                {msg: fmt.Sprintf("Property &lt;%s&gt; with value: &lt;%s&gt; must match pattern: &lt;%s&gt;", buildPathString(path), strValue, pattern)}}
                }</span>

                <span class="cov8" title="1">return []YamlValidationIssue{}</span>
        }
}

func prettifyPath(path string) string <span class="cov8" title="1">{
        wrongIdxSyntax, _ := regexp.Compile("\\.\\[")

        return wrongIdxSyntax.ReplaceAllString(path, "[")
}</span>

func buildPathString(path []string) string <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return "root"
        }</span>

        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov8" title="1">{
                return buildPathString(append([]string{"root"}, path...))
        }</span>
        <span class="cov8" title="1">pathStr := strings.Join(append(path), ".")

        prettyPathStr := prettifyPath(pathStr)

        return prettyPathStr</span>
}

func last(sl []string) string <span class="cov8" title="1">{
        return sl[len(sl)-1]
}</span>

func dropRight(sl []string) []string <span class="cov8" title="1">{
        return sl[:len(sl)-1]
}</span>

func getLiteralStringValue(y *simpleyaml.Yaml) string <span class="cov8" title="1">{
        strVal, strErr := y.String()

        if strErr == nil </span><span class="cov8" title="1">{
                return strVal
        }</span>

        <span class="cov8" title="1">boolVal, boolErr := y.Bool()
        if boolErr == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%t", boolVal)
        }</span>

        <span class="cov8" title="1">IntVal, IntErr := y.Int()
        if IntErr == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d", IntVal)
        }</span>

        // TODO: Literal format of float? How to do with transformation?
        // https://golang.org/pkg/fmt/
        <span class="cov0" title="0">return ""</span>
}

// Given a YAML text and a set of validations will execute them and will return relevant issue slice
// And an "err" object in case of a parsing error.
func ValidateYaml(yaml []byte, validations ...YamlCheck) ([]YamlValidationIssue, error) <span class="cov8" title="1">{
        var issues []YamlValidationIssue

        y, parseError := simpleyaml.NewYaml(yaml)
        if parseError != nil </span><span class="cov8" title="1">{
                return issues, parseError
        }</span>

        <span class="cov8" title="1">for _, validation := range validations </span><span class="cov8" title="1">{
                issues = append(issues, validation(y, []string{})...)
        }</span>

        <span class="cov8" title="1">return issues, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
